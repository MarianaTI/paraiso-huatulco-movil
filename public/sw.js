/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./public/service-worker.js":
/*!**********************************!*\
  !*** ./public/service-worker.js ***!
  \**********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("importScripts(\"https://storage.googleapis.com/workbox-cdn/releases/6.5.4/workbox-sw.js\");\nworkbox.precaching.precacheAndRoute([]);\nworkbox.routing.registerRoute((param)=>{\n    let { request } = param;\n    return request.mode === \"navigate\";\n}, new workbox.strategies.NetworkFirst({\n    cacheName: \"spa-pages\",\n    plugins: [\n        new workbox.expiration.ExpirationPlugin({\n            maxEntries: 20,\n            maxAgeSeconds: 7 * 24 * 60 * 60\n        })\n    ]\n}));\nself.addEventListener(\"fetch\", (event)=>{\n    if (event.request.mode === \"navigate\") {\n        event.respondWith(fetch(event.request).catch(()=>caches.match(\"/index.html\")));\n    }\n});\nworkbox.routing.registerRoute(/^https:\\/\\/admindemo\\.paraisohuatulco\\.com\\/admin\\/products\\/getProductsMovil/, new workbox.strategies.CacheFirst({\n    cacheName: \"products-cache\",\n    plugins: [\n        new workbox.expiration.ExpirationPlugin({\n            maxEntries: 50,\n            maxAgeSeconds: 7 * 24 * 60 * 60\n        })\n    ]\n}));\nworkbox.routing.registerRoute(/^https:\\/\\/pwa\\.paraisohuatulco\\.com\\/[a-zA-Z0-9_-]+\\/$/, new workbox.strategies.CacheFirst({\n    cacheName: \"dynamic-pages\",\n    plugins: [\n        new workbox.expiration.ExpirationPlugin({\n            maxEntries: 100,\n            maxAgeSeconds: 7 * 24 * 60 * 60\n        })\n    ]\n}));\nworkbox.routing.registerRoute((param)=>{\n    let { request } = param;\n    return request.destination === \"document\";\n}, new workbox.strategies.CacheFirst({\n    cacheName: \"pages\",\n    plugins: [\n        new workbox.expiration.ExpirationPlugin({\n            maxEntries: 50,\n            maxAgeSeconds: 7 * 24 * 60 * 60\n        })\n    ]\n}));\nworkbox.routing.registerRoute(/\\.(?:png|jpg|jpeg|svg|gif)$/, new workbox.strategies.CacheFirst({\n    cacheName: \"images\",\n    plugins: [\n        new workbox.expiration.ExpirationPlugin({\n            maxEntries: 60,\n            maxAgeSeconds: 30 * 24 * 60 * 60\n        })\n    ]\n}));\nworkbox.routing.registerRoute(/\\.(?:js|css)$/, new workbox.strategies.CacheFirst({\n    cacheName: \"static-resources\",\n    plugins: [\n        new workbox.expiration.ExpirationPlugin({\n            maxEntries: 60,\n            maxAgeSeconds: 24 * 60 * 60\n        })\n    ]\n}));\nself.addEventListener(\"install\", (event)=>{\n    // console.log('[SW] Instalado');\n    self.skipWaiting();\n});\nself.addEventListener(\"activate\", (event)=>{\n    // console.log('[SW] Activado');\n    return self.clients.claim();\n});\n// Manejo del evento de sincronizaciÃ³n de fondo\n// self.addEventListener('sync', (event) => {\n//   if (event.tag === 'sync-bookings') {\n//     console.log('[SW] Evento de sincronizaciÃ³n recibido');\n//     event.waitUntil(sendOfflineBookingsToServer());\n//   }\n// });\n// // Manejo de mensaje manual desde la app\n// self.addEventListener(\"message\", (event) => {\n//   if (event.data && event.data.action === \"force-sync-bookings\") {\n//     console.log(\"[SW] ðŸ”„ Forzando sincronizaciÃ³n manual\");\n//     event.waitUntil(sendOfflineBookingsToServer());\n//   }\n// });\n// FunciÃ³n para enviar reservas offline\n// const sendOfflineBookingsToServer = async () => {\n//   // console.log('[SW] Enviando reservas offline al servidor...');\n//   const db = await getOfflineDB();\n//   const tx = db.transaction('reservas', 'readwrite');\n//   const store = tx.objectStore('reservas');\n//   const reservas = await store.getAll();\n//   console.log(`[SW] Reservas encontradas para enviar: ${reservas.length}`, reservas);\n//   reservas.onsuccess = async () => {\n//     const all = reservas.result;\n//     // console.log(`[SW] ${all.length} reservas encontradas`);\n//     console.log(`[SW] Reservas encontradas para enviar: ${all.length}`, all);\n//     for (const reserva of all) {\n//       try {\n//         const formData = new FormData();\n//         for (const key in reserva) {\n//           if (reserva[key] !== undefined && reserva[key] !== null) {\n//             formData.append(key, reserva[key]);\n//           }\n//         }\n//         console.log(\"data en el service worker\", formData);\n//         const res = await fetch('https://portaldemo.paraisohuatulco.com/rents/booking', {\n//           method: 'POST',\n//           body: formData,\n//         });\n//         if (res.ok) {\n//           // ðŸ” Crear NUEVA transacciÃ³n para eliminar\n//           const deleteTx = db.transaction('reservas', 'readwrite');\n//           const deleteStore = deleteTx.objectStore('reservas');\n//           await deleteStore.delete(reserva.uuid);\n//           await deleteTx.done;\n//           console.log(`[SW] Reserva ${reserva.uuid} eliminada de IndexedDB`);\n//           // console.log(`[SW] âœ… Reserva enviada y eliminada: ${reserva.id}`);\n//           // NotificaciÃ³n\n//           self.registration.showNotification(\"Reserva enviada\", {\n//             body: \"Tu reserva offline fue enviada correctamente.\",\n//             icon: \"/icon512_rounded.png\",\n//           });\n//         } else {\n//           console.warn('[SW] âš ï¸ Error del servidor al reenviar reserva');\n//         }\n//       } catch (error) {\n//         console.error('[SW] âŒ Error de red:', error);\n//       }\n//     }\n//   };\n//   reservas.onerror = () => {\n//     console.error('[SW] âŒ Error al leer reservas de IndexedDB');\n//   };\n// };\n// IndexedDB setup\nconst getOfflineDB = async ()=>{\n    return await new Promise((resolve, reject)=>{\n        const request = indexedDB.open(\"offline-db\", 1);\n        request.onupgradeneeded = (event)=>{\n            const db = event.target.result;\n            if (!db.objectStoreNames.contains(\"reservas\")) {\n                db.createObjectStore(\"reservas\", {\n                    keyPath: \"uuid\"\n                });\n            }\n        };\n        request.onsuccess = ()=>resolve(request.result);\n        request.onerror = ()=>reject(request.error);\n    });\n};\n// FunciÃ³n para enviar reservas offline\nlet syncInProgress = false;\nconst sendOfflineBookingsToServer = async ()=>{\n    if (syncInProgress) {\n        console.log(\"[SW] â³ SincronizaciÃ³n ya en curso\");\n        return;\n    }\n    syncInProgress = true;\n    try {\n        console.log(\"[SW] Enviando reservas offline al servidor...\");\n        const db = await getOfflineDB();\n        // Paso 1: Obtener TODAS las reservas en una transacciÃ³n de SOLO LECTURA\n        let reservas = [];\n        try {\n            const readTx = db.transaction(\"reservas\", \"readonly\");\n            const readStore = readTx.objectStore(\"reservas\");\n            const request = readStore.getAll();\n            reservas = await new Promise((resolve, reject)=>{\n                request.onsuccess = (event)=>resolve(event.target.result);\n                request.onerror = (event)=>reject(event.target.error);\n            });\n        // No necesitamos await readTx.done aquÃ­ porque es readonly y se completa sola.\n        } catch (error) {\n            console.error(\"[SW] âŒ Error al leer reservas de IndexedDB:\", error);\n            return;\n        }\n        console.log(\"[SW] Reservas encontradas para enviar: \".concat(reservas.length), reservas);\n        if (reservas.length === 0) {\n            console.log(\"[SW] No hay reservas offline para enviar.\");\n            return;\n        }\n        // Paso 2: Iterar sobre cada reserva y procesarla individualmente\n        for (const reserva of reservas){\n            try {\n                const formData = new FormData();\n                for(const key in reserva){\n                    if (reserva[key] !== undefined && reserva[key] !== null) {\n                        formData.append(key, reserva[key]);\n                    }\n                }\n                console.log(\"[SW] Intentando enviar reserva con UUID: \".concat(reserva.uuid));\n                console.log(\"data en el service worker\", Array.from(formData.entries()));\n                const res = await fetch(\"https://portaldemo.paraisohuatulco.com/rents/booking\", {\n                    method: \"POST\",\n                    body: formData\n                });\n                if (res.ok) {\n                    // Paso 3: Si el envÃ­o es exitoso, abrir UNA NUEVA TRANSACCIÃ“N para eliminar\n                    try {\n                        const deleteTx = db.transaction(\"reservas\", \"readwrite\");\n                        const deleteStore = deleteTx.objectStore(\"reservas\");\n                        const deleteRequest = deleteStore.delete(reserva.uuid);\n                        await new Promise((resolve, reject)=>{\n                            deleteRequest.onsuccess = ()=>resolve();\n                            deleteRequest.onerror = (event)=>reject(event.target.error);\n                        });\n                        await deleteTx.done; // Esperar a que esta transacciÃ³n de eliminaciÃ³n se complete.\n                        console.log(\"[SW] Reserva \".concat(reserva.uuid, \" eliminada de IndexedDB exitosamente.\"));\n                        self.registration.showNotification(\"Reserva enviada\", {\n                            body: \"Tu reserva offline fue enviada correctamente.\",\n                            icon: \"/icon512_rounded.png\"\n                        });\n                    } catch (deleteError) {\n                        console.error(\"[SW] âŒ Error al eliminar reserva \".concat(reserva.uuid, \" de IndexedDB:\"), deleteError);\n                    // Si falla la eliminaciÃ³n, la reserva seguirÃ¡ allÃ­ y se reintentarÃ¡, lo cual no es ideal pero es seguro.\n                    }\n                } else {\n                    console.warn(\"[SW] âš ï¸ Error del servidor al reenviar reserva \".concat(reserva.uuid, \":\"), res.status, res.statusText);\n                // NO ELIMINAR: Si hay un error del servidor, la reserva debe permanecer para un reintento futuro.\n                }\n            } catch (networkError) {\n                console.error(\"[SW] âŒ Error de red al enviar reserva \".concat(reserva.uuid, \":\"), networkError);\n            // NO ELIMINAR: Si hay un error de red, la reserva debe permanecer para que Background Sync la reintente.\n            }\n        }\n        console.log(\"[SW] Procesamiento de reservas offline completado.\");\n    } finally{\n        syncInProgress = false;\n    }\n};\nself.addEventListener(\"message\", (event)=>{\n    var _event_data;\n    if (((_event_data = event.data) === null || _event_data === void 0 ? void 0 : _event_data.action) === \"force-sync-bookings\") {\n        console.log(\"[SW] ðŸ”„ Forzando sincronizaciÃ³n manual\");\n        event.waitUntil(sendOfflineBookingsToServer());\n    }\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                /* unsupported import.meta.webpackHot */ undefined.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LFFBQVFILEtBQUssQ0FDWCxvQ0FBaUQsT0FBYlksUUFBUU0sSUFBSSxFQUFDLG1CQUNqRGdCO29CQUVGLHlHQUF5RztvQkFDM0c7Z0JBQ0YsT0FBTztvQkFDTC9CLFFBQVFnQyxJQUFJLENBQ1Ysa0RBQStELE9BQWJ2QixRQUFRTSxJQUFJLEVBQUMsTUFDL0RJLElBQUljLE1BQU0sRUFDVmQsSUFBSWUsVUFBVTtnQkFFaEIsa0dBQWtHO2dCQUNwRztZQUNGLEVBQUUsT0FBT0MsY0FBYztnQkFDckJuQyxRQUFRSCxLQUFLLENBQ1gseUNBQXNELE9BQWJZLFFBQVFNLElBQUksRUFBQyxNQUN0RG9CO1lBRUYseUdBQXlHO1lBQzNHO1FBQ0Y7UUFDQW5DLFFBQVFDLEdBQUcsQ0FBQztJQUNkLFNBQVU7UUFDUkgsaUJBQWlCO0lBQ25CO0FBQ0Y7QUFFQTNDLEtBQUtjLGdCQUFnQixDQUFDLFdBQVcsQ0FBQ0M7UUFDNUJBO0lBQUosSUFBSUEsRUFBQUEsY0FBQUEsTUFBTWtFLElBQUksY0FBVmxFLGtDQUFBQSxZQUFZbUUsTUFBTSxNQUFLLHVCQUF1QjtRQUNoRHJDLFFBQVFDLEdBQUcsQ0FBQztRQUNaL0IsTUFBTW9FLFNBQVMsQ0FBQ3ZDO0lBQ2xCO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxTb2x1Y2lvbmVzSURcXFByb3llY3RvXFxwYXJhaXNvLWh1YXR1bGNvLW1vdmlsXFxwYXJhaXNvLWh1YXR1bGNvLW1vdmlsXFxwdWJsaWNcXHNlcnZpY2Utd29ya2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydFNjcmlwdHMoXHJcbiAgXCJodHRwczovL3N0b3JhZ2UuZ29vZ2xlYXBpcy5jb20vd29ya2JveC1jZG4vcmVsZWFzZXMvNi41LjQvd29ya2JveC1zdy5qc1wiXHJcbik7XHJcblxyXG53b3JrYm94LnByZWNhY2hpbmcucHJlY2FjaGVBbmRSb3V0ZShzZWxmLl9fV0JfTUFOSUZFU1QpO1xyXG5cclxud29ya2JveC5yb3V0aW5nLnJlZ2lzdGVyUm91dGUoXHJcbiAgKHsgcmVxdWVzdCB9KSA9PiByZXF1ZXN0Lm1vZGUgPT09IFwibmF2aWdhdGVcIixcclxuICBuZXcgd29ya2JveC5zdHJhdGVnaWVzLk5ldHdvcmtGaXJzdCh7XHJcbiAgICBjYWNoZU5hbWU6IFwic3BhLXBhZ2VzXCIsXHJcbiAgICBwbHVnaW5zOiBbXHJcbiAgICAgIG5ldyB3b3JrYm94LmV4cGlyYXRpb24uRXhwaXJhdGlvblBsdWdpbih7XHJcbiAgICAgICAgbWF4RW50cmllczogMjAsXHJcbiAgICAgICAgbWF4QWdlU2Vjb25kczogNyAqIDI0ICogNjAgKiA2MCxcclxuICAgICAgfSksXHJcbiAgICBdLFxyXG4gIH0pXHJcbik7XHJcblxyXG5zZWxmLmFkZEV2ZW50TGlzdGVuZXIoXCJmZXRjaFwiLCAoZXZlbnQpID0+IHtcclxuICBpZiAoZXZlbnQucmVxdWVzdC5tb2RlID09PSBcIm5hdmlnYXRlXCIpIHtcclxuICAgIGV2ZW50LnJlc3BvbmRXaXRoKFxyXG4gICAgICBmZXRjaChldmVudC5yZXF1ZXN0KS5jYXRjaCgoKSA9PiBjYWNoZXMubWF0Y2goXCIvaW5kZXguaHRtbFwiKSlcclxuICAgICk7XHJcbiAgfVxyXG59KTtcclxuXHJcbndvcmtib3gucm91dGluZy5yZWdpc3RlclJvdXRlKFxyXG4gIC9eaHR0cHM6XFwvXFwvYWRtaW5kZW1vXFwucGFyYWlzb2h1YXR1bGNvXFwuY29tXFwvYWRtaW5cXC9wcm9kdWN0c1xcL2dldFByb2R1Y3RzTW92aWwvLFxyXG4gIG5ldyB3b3JrYm94LnN0cmF0ZWdpZXMuQ2FjaGVGaXJzdCh7XHJcbiAgICBjYWNoZU5hbWU6IFwicHJvZHVjdHMtY2FjaGVcIixcclxuICAgIHBsdWdpbnM6IFtcclxuICAgICAgbmV3IHdvcmtib3guZXhwaXJhdGlvbi5FeHBpcmF0aW9uUGx1Z2luKHtcclxuICAgICAgICBtYXhFbnRyaWVzOiA1MCxcclxuICAgICAgICBtYXhBZ2VTZWNvbmRzOiA3ICogMjQgKiA2MCAqIDYwLFxyXG4gICAgICB9KSxcclxuICAgIF0sXHJcbiAgfSlcclxuKTtcclxuXHJcbndvcmtib3gucm91dGluZy5yZWdpc3RlclJvdXRlKFxyXG4gIC9eaHR0cHM6XFwvXFwvcHdhXFwucGFyYWlzb2h1YXR1bGNvXFwuY29tXFwvW2EtekEtWjAtOV8tXStcXC8kLyxcclxuICBuZXcgd29ya2JveC5zdHJhdGVnaWVzLkNhY2hlRmlyc3Qoe1xyXG4gICAgY2FjaGVOYW1lOiBcImR5bmFtaWMtcGFnZXNcIixcclxuICAgIHBsdWdpbnM6IFtcclxuICAgICAgbmV3IHdvcmtib3guZXhwaXJhdGlvbi5FeHBpcmF0aW9uUGx1Z2luKHtcclxuICAgICAgICBtYXhFbnRyaWVzOiAxMDAsXHJcbiAgICAgICAgbWF4QWdlU2Vjb25kczogNyAqIDI0ICogNjAgKiA2MCxcclxuICAgICAgfSksXHJcbiAgICBdLFxyXG4gIH0pXHJcbik7XHJcblxyXG53b3JrYm94LnJvdXRpbmcucmVnaXN0ZXJSb3V0ZShcclxuICAoeyByZXF1ZXN0IH0pID0+IHJlcXVlc3QuZGVzdGluYXRpb24gPT09IFwiZG9jdW1lbnRcIixcclxuICBuZXcgd29ya2JveC5zdHJhdGVnaWVzLkNhY2hlRmlyc3Qoe1xyXG4gICAgY2FjaGVOYW1lOiBcInBhZ2VzXCIsXHJcbiAgICBwbHVnaW5zOiBbXHJcbiAgICAgIG5ldyB3b3JrYm94LmV4cGlyYXRpb24uRXhwaXJhdGlvblBsdWdpbih7XHJcbiAgICAgICAgbWF4RW50cmllczogNTAsXHJcbiAgICAgICAgbWF4QWdlU2Vjb25kczogNyAqIDI0ICogNjAgKiA2MCxcclxuICAgICAgfSksXHJcbiAgICBdLFxyXG4gIH0pXHJcbik7XHJcblxyXG53b3JrYm94LnJvdXRpbmcucmVnaXN0ZXJSb3V0ZShcclxuICAvXFwuKD86cG5nfGpwZ3xqcGVnfHN2Z3xnaWYpJC8sXHJcbiAgbmV3IHdvcmtib3guc3RyYXRlZ2llcy5DYWNoZUZpcnN0KHtcclxuICAgIGNhY2hlTmFtZTogXCJpbWFnZXNcIixcclxuICAgIHBsdWdpbnM6IFtcclxuICAgICAgbmV3IHdvcmtib3guZXhwaXJhdGlvbi5FeHBpcmF0aW9uUGx1Z2luKHtcclxuICAgICAgICBtYXhFbnRyaWVzOiA2MCxcclxuICAgICAgICBtYXhBZ2VTZWNvbmRzOiAzMCAqIDI0ICogNjAgKiA2MCxcclxuICAgICAgfSksXHJcbiAgICBdLFxyXG4gIH0pXHJcbik7XHJcblxyXG53b3JrYm94LnJvdXRpbmcucmVnaXN0ZXJSb3V0ZShcclxuICAvXFwuKD86anN8Y3NzKSQvLFxyXG4gIG5ldyB3b3JrYm94LnN0cmF0ZWdpZXMuQ2FjaGVGaXJzdCh7XHJcbiAgICBjYWNoZU5hbWU6IFwic3RhdGljLXJlc291cmNlc1wiLFxyXG4gICAgcGx1Z2luczogW1xyXG4gICAgICBuZXcgd29ya2JveC5leHBpcmF0aW9uLkV4cGlyYXRpb25QbHVnaW4oe1xyXG4gICAgICAgIG1heEVudHJpZXM6IDYwLFxyXG4gICAgICAgIG1heEFnZVNlY29uZHM6IDI0ICogNjAgKiA2MCxcclxuICAgICAgfSksXHJcbiAgICBdLFxyXG4gIH0pXHJcbik7XHJcblxyXG5zZWxmLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnN0YWxsXCIsIChldmVudCkgPT4ge1xyXG4gIC8vIGNvbnNvbGUubG9nKCdbU1ddIEluc3RhbGFkbycpO1xyXG4gIHNlbGYuc2tpcFdhaXRpbmcoKTtcclxufSk7XHJcblxyXG5zZWxmLmFkZEV2ZW50TGlzdGVuZXIoXCJhY3RpdmF0ZVwiLCAoZXZlbnQpID0+IHtcclxuICAvLyBjb25zb2xlLmxvZygnW1NXXSBBY3RpdmFkbycpO1xyXG4gIHJldHVybiBzZWxmLmNsaWVudHMuY2xhaW0oKTtcclxufSk7XHJcblxyXG4vLyBNYW5lam8gZGVsIGV2ZW50byBkZSBzaW5jcm9uaXphY2nDs24gZGUgZm9uZG9cclxuLy8gc2VsZi5hZGRFdmVudExpc3RlbmVyKCdzeW5jJywgKGV2ZW50KSA9PiB7XHJcbi8vICAgaWYgKGV2ZW50LnRhZyA9PT0gJ3N5bmMtYm9va2luZ3MnKSB7XHJcbi8vICAgICBjb25zb2xlLmxvZygnW1NXXSBFdmVudG8gZGUgc2luY3Jvbml6YWNpw7NuIHJlY2liaWRvJyk7XHJcbi8vICAgICBldmVudC53YWl0VW50aWwoc2VuZE9mZmxpbmVCb29raW5nc1RvU2VydmVyKCkpO1xyXG4vLyAgIH1cclxuLy8gfSk7XHJcblxyXG4vLyAvLyBNYW5lam8gZGUgbWVuc2FqZSBtYW51YWwgZGVzZGUgbGEgYXBwXHJcbi8vIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgKGV2ZW50KSA9PiB7XHJcbi8vICAgaWYgKGV2ZW50LmRhdGEgJiYgZXZlbnQuZGF0YS5hY3Rpb24gPT09IFwiZm9yY2Utc3luYy1ib29raW5nc1wiKSB7XHJcbi8vICAgICBjb25zb2xlLmxvZyhcIltTV10g8J+UhCBGb3J6YW5kbyBzaW5jcm9uaXphY2nDs24gbWFudWFsXCIpO1xyXG4vLyAgICAgZXZlbnQud2FpdFVudGlsKHNlbmRPZmZsaW5lQm9va2luZ3NUb1NlcnZlcigpKTtcclxuLy8gICB9XHJcbi8vIH0pO1xyXG5cclxuLy8gRnVuY2nDs24gcGFyYSBlbnZpYXIgcmVzZXJ2YXMgb2ZmbGluZVxyXG4vLyBjb25zdCBzZW5kT2ZmbGluZUJvb2tpbmdzVG9TZXJ2ZXIgPSBhc3luYyAoKSA9PiB7XHJcbi8vICAgLy8gY29uc29sZS5sb2coJ1tTV10gRW52aWFuZG8gcmVzZXJ2YXMgb2ZmbGluZSBhbCBzZXJ2aWRvci4uLicpO1xyXG4vLyAgIGNvbnN0IGRiID0gYXdhaXQgZ2V0T2ZmbGluZURCKCk7XHJcbi8vICAgY29uc3QgdHggPSBkYi50cmFuc2FjdGlvbigncmVzZXJ2YXMnLCAncmVhZHdyaXRlJyk7XHJcbi8vICAgY29uc3Qgc3RvcmUgPSB0eC5vYmplY3RTdG9yZSgncmVzZXJ2YXMnKTtcclxuLy8gICBjb25zdCByZXNlcnZhcyA9IGF3YWl0IHN0b3JlLmdldEFsbCgpO1xyXG5cclxuLy8gICBjb25zb2xlLmxvZyhgW1NXXSBSZXNlcnZhcyBlbmNvbnRyYWRhcyBwYXJhIGVudmlhcjogJHtyZXNlcnZhcy5sZW5ndGh9YCwgcmVzZXJ2YXMpO1xyXG5cclxuLy8gICByZXNlcnZhcy5vbnN1Y2Nlc3MgPSBhc3luYyAoKSA9PiB7XHJcbi8vICAgICBjb25zdCBhbGwgPSByZXNlcnZhcy5yZXN1bHQ7XHJcbi8vICAgICAvLyBjb25zb2xlLmxvZyhgW1NXXSAke2FsbC5sZW5ndGh9IHJlc2VydmFzIGVuY29udHJhZGFzYCk7XHJcbi8vICAgICBjb25zb2xlLmxvZyhgW1NXXSBSZXNlcnZhcyBlbmNvbnRyYWRhcyBwYXJhIGVudmlhcjogJHthbGwubGVuZ3RofWAsIGFsbCk7XHJcbi8vICAgICBmb3IgKGNvbnN0IHJlc2VydmEgb2YgYWxsKSB7XHJcbi8vICAgICAgIHRyeSB7XHJcbi8vICAgICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcclxuLy8gICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiByZXNlcnZhKSB7XHJcbi8vICAgICAgICAgICBpZiAocmVzZXJ2YVtrZXldICE9PSB1bmRlZmluZWQgJiYgcmVzZXJ2YVtrZXldICE9PSBudWxsKSB7XHJcbi8vICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChrZXksIHJlc2VydmFba2V5XSk7XHJcbi8vICAgICAgICAgICB9XHJcbi8vICAgICAgICAgfVxyXG5cclxuLy8gICAgICAgICBjb25zb2xlLmxvZyhcImRhdGEgZW4gZWwgc2VydmljZSB3b3JrZXJcIiwgZm9ybURhdGEpO1xyXG5cclxuLy8gICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCgnaHR0cHM6Ly9wb3J0YWxkZW1vLnBhcmFpc29odWF0dWxjby5jb20vcmVudHMvYm9va2luZycsIHtcclxuLy8gICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4vLyAgICAgICAgICAgYm9keTogZm9ybURhdGEsXHJcbi8vICAgICAgICAgfSk7XHJcblxyXG4vLyAgICAgICAgIGlmIChyZXMub2spIHtcclxuLy8gICAgICAgICAgIC8vIPCflIEgQ3JlYXIgTlVFVkEgdHJhbnNhY2Npw7NuIHBhcmEgZWxpbWluYXJcclxuLy8gICAgICAgICAgIGNvbnN0IGRlbGV0ZVR4ID0gZGIudHJhbnNhY3Rpb24oJ3Jlc2VydmFzJywgJ3JlYWR3cml0ZScpO1xyXG4vLyAgICAgICAgICAgY29uc3QgZGVsZXRlU3RvcmUgPSBkZWxldGVUeC5vYmplY3RTdG9yZSgncmVzZXJ2YXMnKTtcclxuLy8gICAgICAgICAgIGF3YWl0IGRlbGV0ZVN0b3JlLmRlbGV0ZShyZXNlcnZhLnV1aWQpO1xyXG4vLyAgICAgICAgICAgYXdhaXQgZGVsZXRlVHguZG9uZTtcclxuLy8gICAgICAgICAgIGNvbnNvbGUubG9nKGBbU1ddIFJlc2VydmEgJHtyZXNlcnZhLnV1aWR9IGVsaW1pbmFkYSBkZSBJbmRleGVkREJgKTtcclxuLy8gICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGBbU1ddIOKchSBSZXNlcnZhIGVudmlhZGEgeSBlbGltaW5hZGE6ICR7cmVzZXJ2YS5pZH1gKTtcclxuXHJcbi8vICAgICAgICAgICAvLyBOb3RpZmljYWNpw7NuXHJcbi8vICAgICAgICAgICBzZWxmLnJlZ2lzdHJhdGlvbi5zaG93Tm90aWZpY2F0aW9uKFwiUmVzZXJ2YSBlbnZpYWRhXCIsIHtcclxuLy8gICAgICAgICAgICAgYm9keTogXCJUdSByZXNlcnZhIG9mZmxpbmUgZnVlIGVudmlhZGEgY29ycmVjdGFtZW50ZS5cIixcclxuLy8gICAgICAgICAgICAgaWNvbjogXCIvaWNvbjUxMl9yb3VuZGVkLnBuZ1wiLFxyXG4vLyAgICAgICAgICAgfSk7XHJcbi8vICAgICAgICAgfSBlbHNlIHtcclxuLy8gICAgICAgICAgIGNvbnNvbGUud2FybignW1NXXSDimqDvuI8gRXJyb3IgZGVsIHNlcnZpZG9yIGFsIHJlZW52aWFyIHJlc2VydmEnKTtcclxuLy8gICAgICAgICB9XHJcbi8vICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbi8vICAgICAgICAgY29uc29sZS5lcnJvcignW1NXXSDinYwgRXJyb3IgZGUgcmVkOicsIGVycm9yKTtcclxuLy8gICAgICAgfVxyXG4vLyAgICAgfVxyXG4vLyAgIH07XHJcblxyXG4vLyAgIHJlc2VydmFzLm9uZXJyb3IgPSAoKSA9PiB7XHJcbi8vICAgICBjb25zb2xlLmVycm9yKCdbU1ddIOKdjCBFcnJvciBhbCBsZWVyIHJlc2VydmFzIGRlIEluZGV4ZWREQicpO1xyXG4vLyAgIH07XHJcbi8vIH07XHJcblxyXG4vLyBJbmRleGVkREIgc2V0dXBcclxuY29uc3QgZ2V0T2ZmbGluZURCID0gYXN5bmMgKCkgPT4ge1xyXG4gIHJldHVybiBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICBjb25zdCByZXF1ZXN0ID0gaW5kZXhlZERCLm9wZW4oXCJvZmZsaW5lLWRiXCIsIDEpO1xyXG4gICAgcmVxdWVzdC5vbnVwZ3JhZGVuZWVkZWQgPSAoZXZlbnQpID0+IHtcclxuICAgICAgY29uc3QgZGIgPSBldmVudC50YXJnZXQucmVzdWx0O1xyXG4gICAgICBpZiAoIWRiLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnMoXCJyZXNlcnZhc1wiKSkge1xyXG4gICAgICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKFwicmVzZXJ2YXNcIiwge1xyXG4gICAgICAgICAga2V5UGF0aDogXCJ1dWlkXCIsXHJcbiAgICAgICAgICAvLyBhdXRvSW5jcmVtZW50OiB0cnVlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiByZXNvbHZlKHJlcXVlc3QucmVzdWx0KTtcclxuICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHJlamVjdChyZXF1ZXN0LmVycm9yKTtcclxuICB9KTtcclxufTtcclxuXHJcbi8vIEZ1bmNpw7NuIHBhcmEgZW52aWFyIHJlc2VydmFzIG9mZmxpbmVcclxubGV0IHN5bmNJblByb2dyZXNzID0gZmFsc2U7XHJcblxyXG5jb25zdCBzZW5kT2ZmbGluZUJvb2tpbmdzVG9TZXJ2ZXIgPSBhc3luYyAoKSA9PiB7XHJcbiAgaWYgKHN5bmNJblByb2dyZXNzKSB7XHJcbiAgICBjb25zb2xlLmxvZyhcIltTV10g4o+zIFNpbmNyb25pemFjacOzbiB5YSBlbiBjdXJzb1wiKTtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgc3luY0luUHJvZ3Jlc3MgPSB0cnVlO1xyXG5cclxuICB0cnkge1xyXG4gICAgY29uc29sZS5sb2coXCJbU1ddIEVudmlhbmRvIHJlc2VydmFzIG9mZmxpbmUgYWwgc2Vydmlkb3IuLi5cIik7XHJcbiAgICBjb25zdCBkYiA9IGF3YWl0IGdldE9mZmxpbmVEQigpO1xyXG5cclxuICAgIC8vIFBhc28gMTogT2J0ZW5lciBUT0RBUyBsYXMgcmVzZXJ2YXMgZW4gdW5hIHRyYW5zYWNjacOzbiBkZSBTT0xPIExFQ1RVUkFcclxuICAgIGxldCByZXNlcnZhcyA9IFtdO1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVhZFR4ID0gZGIudHJhbnNhY3Rpb24oXCJyZXNlcnZhc1wiLCBcInJlYWRvbmx5XCIpO1xyXG4gICAgICBjb25zdCByZWFkU3RvcmUgPSByZWFkVHgub2JqZWN0U3RvcmUoXCJyZXNlcnZhc1wiKTtcclxuICAgICAgY29uc3QgcmVxdWVzdCA9IHJlYWRTdG9yZS5nZXRBbGwoKTtcclxuICAgICAgcmVzZXJ2YXMgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoZXZlbnQpID0+IHJlc29sdmUoZXZlbnQudGFyZ2V0LnJlc3VsdCk7XHJcbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKGV2ZW50KSA9PiByZWplY3QoZXZlbnQudGFyZ2V0LmVycm9yKTtcclxuICAgICAgfSk7XHJcbiAgICAgIC8vIE5vIG5lY2VzaXRhbW9zIGF3YWl0IHJlYWRUeC5kb25lIGFxdcOtIHBvcnF1ZSBlcyByZWFkb25seSB5IHNlIGNvbXBsZXRhIHNvbGEuXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiW1NXXSDinYwgRXJyb3IgYWwgbGVlciByZXNlcnZhcyBkZSBJbmRleGVkREI6XCIsIGVycm9yKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICBgW1NXXSBSZXNlcnZhcyBlbmNvbnRyYWRhcyBwYXJhIGVudmlhcjogJHtyZXNlcnZhcy5sZW5ndGh9YCxcclxuICAgICAgcmVzZXJ2YXNcclxuICAgICk7XHJcblxyXG4gICAgaWYgKHJlc2VydmFzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICBjb25zb2xlLmxvZyhcIltTV10gTm8gaGF5IHJlc2VydmFzIG9mZmxpbmUgcGFyYSBlbnZpYXIuXCIpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUGFzbyAyOiBJdGVyYXIgc29icmUgY2FkYSByZXNlcnZhIHkgcHJvY2VzYXJsYSBpbmRpdmlkdWFsbWVudGVcclxuICAgIGZvciAoY29uc3QgcmVzZXJ2YSBvZiByZXNlcnZhcykge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcmVzZXJ2YSkge1xyXG4gICAgICAgICAgaWYgKHJlc2VydmFba2V5XSAhPT0gdW5kZWZpbmVkICYmIHJlc2VydmFba2V5XSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoa2V5LCByZXNlcnZhW2tleV0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coYFtTV10gSW50ZW50YW5kbyBlbnZpYXIgcmVzZXJ2YSBjb24gVVVJRDogJHtyZXNlcnZhLnV1aWR9YCk7XHJcbiAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICBcImRhdGEgZW4gZWwgc2VydmljZSB3b3JrZXJcIixcclxuICAgICAgICAgIEFycmF5LmZyb20oZm9ybURhdGEuZW50cmllcygpKVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKFxyXG4gICAgICAgICAgXCJodHRwczovL3BvcnRhbGRlbW8ucGFyYWlzb2h1YXR1bGNvLmNvbS9yZW50cy9ib29raW5nXCIsXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXHJcbiAgICAgICAgICAgIGJvZHk6IGZvcm1EYXRhLFxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGlmIChyZXMub2spIHtcclxuICAgICAgICAgIC8vIFBhc28gMzogU2kgZWwgZW52w61vIGVzIGV4aXRvc28sIGFicmlyIFVOQSBOVUVWQSBUUkFOU0FDQ0nDk04gcGFyYSBlbGltaW5hclxyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgZGVsZXRlVHggPSBkYi50cmFuc2FjdGlvbihcInJlc2VydmFzXCIsIFwicmVhZHdyaXRlXCIpO1xyXG4gICAgICAgICAgICBjb25zdCBkZWxldGVTdG9yZSA9IGRlbGV0ZVR4Lm9iamVjdFN0b3JlKFwicmVzZXJ2YXNcIik7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlbGV0ZVJlcXVlc3QgPSBkZWxldGVTdG9yZS5kZWxldGUocmVzZXJ2YS51dWlkKTtcclxuXHJcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgICBkZWxldGVSZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICBkZWxldGVSZXF1ZXN0Lm9uZXJyb3IgPSAoZXZlbnQpID0+IHJlamVjdChldmVudC50YXJnZXQuZXJyb3IpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgYXdhaXQgZGVsZXRlVHguZG9uZTsgLy8gRXNwZXJhciBhIHF1ZSBlc3RhIHRyYW5zYWNjacOzbiBkZSBlbGltaW5hY2nDs24gc2UgY29tcGxldGUuXHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgICAgICBgW1NXXSBSZXNlcnZhICR7cmVzZXJ2YS51dWlkfSBlbGltaW5hZGEgZGUgSW5kZXhlZERCIGV4aXRvc2FtZW50ZS5gXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBzZWxmLnJlZ2lzdHJhdGlvbi5zaG93Tm90aWZpY2F0aW9uKFwiUmVzZXJ2YSBlbnZpYWRhXCIsIHtcclxuICAgICAgICAgICAgICBib2R5OiBcIlR1IHJlc2VydmEgb2ZmbGluZSBmdWUgZW52aWFkYSBjb3JyZWN0YW1lbnRlLlwiLFxyXG4gICAgICAgICAgICAgIGljb246IFwiL2ljb241MTJfcm91bmRlZC5wbmdcIixcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9IGNhdGNoIChkZWxldGVFcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxyXG4gICAgICAgICAgICAgIGBbU1ddIOKdjCBFcnJvciBhbCBlbGltaW5hciByZXNlcnZhICR7cmVzZXJ2YS51dWlkfSBkZSBJbmRleGVkREI6YCxcclxuICAgICAgICAgICAgICBkZWxldGVFcnJvclxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAvLyBTaSBmYWxsYSBsYSBlbGltaW5hY2nDs24sIGxhIHJlc2VydmEgc2VndWlyw6EgYWxsw60geSBzZSByZWludGVudGFyw6EsIGxvIGN1YWwgbm8gZXMgaWRlYWwgcGVybyBlcyBzZWd1cm8uXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICAgICAgYFtTV10g4pqg77iPIEVycm9yIGRlbCBzZXJ2aWRvciBhbCByZWVudmlhciByZXNlcnZhICR7cmVzZXJ2YS51dWlkfTpgLFxyXG4gICAgICAgICAgICByZXMuc3RhdHVzLFxyXG4gICAgICAgICAgICByZXMuc3RhdHVzVGV4dFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIC8vIE5PIEVMSU1JTkFSOiBTaSBoYXkgdW4gZXJyb3IgZGVsIHNlcnZpZG9yLCBsYSByZXNlcnZhIGRlYmUgcGVybWFuZWNlciBwYXJhIHVuIHJlaW50ZW50byBmdXR1cm8uXHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChuZXR3b3JrRXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFxyXG4gICAgICAgICAgYFtTV10g4p2MIEVycm9yIGRlIHJlZCBhbCBlbnZpYXIgcmVzZXJ2YSAke3Jlc2VydmEudXVpZH06YCxcclxuICAgICAgICAgIG5ldHdvcmtFcnJvclxyXG4gICAgICAgICk7XHJcbiAgICAgICAgLy8gTk8gRUxJTUlOQVI6IFNpIGhheSB1biBlcnJvciBkZSByZWQsIGxhIHJlc2VydmEgZGViZSBwZXJtYW5lY2VyIHBhcmEgcXVlIEJhY2tncm91bmQgU3luYyBsYSByZWludGVudGUuXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnNvbGUubG9nKFwiW1NXXSBQcm9jZXNhbWllbnRvIGRlIHJlc2VydmFzIG9mZmxpbmUgY29tcGxldGFkby5cIik7XHJcbiAgfSBmaW5hbGx5IHtcclxuICAgIHN5bmNJblByb2dyZXNzID0gZmFsc2U7XHJcbiAgfVxyXG59O1xyXG5cclxuc2VsZi5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoZXZlbnQpID0+IHtcclxuICBpZiAoZXZlbnQuZGF0YT8uYWN0aW9uID09PSBcImZvcmNlLXN5bmMtYm9va2luZ3NcIikge1xyXG4gICAgY29uc29sZS5sb2coXCJbU1ddIPCflIQgRm9yemFuZG8gc2luY3Jvbml6YWNpw7NuIG1hbnVhbFwiKTtcclxuICAgIGV2ZW50LndhaXRVbnRpbChzZW5kT2ZmbGluZUJvb2tpbmdzVG9TZXJ2ZXIoKSk7XHJcbiAgfVxyXG59KTsiXSwibmFtZXMiOlsiaW1wb3J0U2NyaXB0cyIsIndvcmtib3giLCJwcmVjYWNoaW5nIiwicHJlY2FjaGVBbmRSb3V0ZSIsInNlbGYiLCJfX1dCX01BTklGRVNUIiwicm91dGluZyIsInJlZ2lzdGVyUm91dGUiLCJyZXF1ZXN0IiwibW9kZSIsInN0cmF0ZWdpZXMiLCJOZXR3b3JrRmlyc3QiLCJjYWNoZU5hbWUiLCJwbHVnaW5zIiwiZXhwaXJhdGlvbiIsIkV4cGlyYXRpb25QbHVnaW4iLCJtYXhFbnRyaWVzIiwibWF4QWdlU2Vjb25kcyIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudCIsInJlc3BvbmRXaXRoIiwiZmV0Y2giLCJjYXRjaCIsImNhY2hlcyIsIm1hdGNoIiwiQ2FjaGVGaXJzdCIsImRlc3RpbmF0aW9uIiwic2tpcFdhaXRpbmciLCJjbGllbnRzIiwiY2xhaW0iLCJnZXRPZmZsaW5lREIiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImluZGV4ZWREQiIsIm9wZW4iLCJvbnVwZ3JhZGVuZWVkZWQiLCJkYiIsInRhcmdldCIsInJlc3VsdCIsIm9iamVjdFN0b3JlTmFtZXMiLCJjb250YWlucyIsImNyZWF0ZU9iamVjdFN0b3JlIiwia2V5UGF0aCIsIm9uc3VjY2VzcyIsIm9uZXJyb3IiLCJlcnJvciIsInN5bmNJblByb2dyZXNzIiwic2VuZE9mZmxpbmVCb29raW5nc1RvU2VydmVyIiwiY29uc29sZSIsImxvZyIsInJlc2VydmFzIiwicmVhZFR4IiwidHJhbnNhY3Rpb24iLCJyZWFkU3RvcmUiLCJvYmplY3RTdG9yZSIsImdldEFsbCIsImxlbmd0aCIsInJlc2VydmEiLCJmb3JtRGF0YSIsIkZvcm1EYXRhIiwia2V5IiwidW5kZWZpbmVkIiwiYXBwZW5kIiwidXVpZCIsIkFycmF5IiwiZnJvbSIsImVudHJpZXMiLCJyZXMiLCJtZXRob2QiLCJib2R5Iiwib2siLCJkZWxldGVUeCIsImRlbGV0ZVN0b3JlIiwiZGVsZXRlUmVxdWVzdCIsImRlbGV0ZSIsImRvbmUiLCJyZWdpc3RyYXRpb24iLCJzaG93Tm90aWZpY2F0aW9uIiwiaWNvbiIsImRlbGV0ZUVycm9yIiwid2FybiIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJuZXR3b3JrRXJyb3IiLCJkYXRhIiwiYWN0aW9uIiwid2FpdFVudGlsIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./public/service-worker.js\n"));

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			if (cachedModule.error !== undefined) throw cachedModule.error;
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/trusted types policy */
/******/ 	(() => {
/******/ 		var policy;
/******/ 		__webpack_require__.tt = () => {
/******/ 			// Create Trusted Type policy if Trusted Types are available and the policy doesn't exist yet.
/******/ 			if (policy === undefined) {
/******/ 				policy = {
/******/ 					createScript: (script) => (script)
/******/ 				};
/******/ 				if (typeof trustedTypes !== "undefined" && trustedTypes.createPolicy) {
/******/ 					policy = trustedTypes.createPolicy("nextjs#bundler", policy);
/******/ 				}
/******/ 			}
/******/ 			return policy;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/trusted types script */
/******/ 	(() => {
/******/ 		__webpack_require__.ts = (script) => (__webpack_require__.tt().createScript(script));
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/react refresh */
/******/ 	(() => {
/******/ 		if (__webpack_require__.i) {
/******/ 		__webpack_require__.i.push((options) => {
/******/ 			const originalFactory = options.factory;
/******/ 			options.factory = (moduleObject, moduleExports, webpackRequire) => {
/******/ 				const hasRefresh = typeof self !== "undefined" && !!self.$RefreshInterceptModuleExecution$;
/******/ 				const cleanup = hasRefresh ? self.$RefreshInterceptModuleExecution$(moduleObject.id) : () => {};
/******/ 				try {
/******/ 					originalFactory.call(this, moduleObject, moduleExports, webpackRequire);
/******/ 				} finally {
/******/ 					cleanup();
/******/ 				}
/******/ 			}
/******/ 		})
/******/ 		}
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	
/******/ 	// noop fns to prevent runtime errors during initialization
/******/ 	if (typeof self !== "undefined") {
/******/ 		self.$RefreshReg$ = function () {};
/******/ 		self.$RefreshSig$ = function () {
/******/ 			return function (type) {
/******/ 				return type;
/******/ 			};
/******/ 		};
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./public/service-worker.js");
/******/ 	
/******/ })()
;